const NULL 0 end

const stdin  0 end
const stdout 1 end
const stderr 2 end

inline fun + int int -> int : add end
inline fun - int int -> int : sub end
inline fun * int int -> int : mul end
inline fun / int int -> int : div end
inline fun % int int -> int : mod end

inline fun ==   int int   -> bool : eq  end
inline fun !=   int int   -> bool : ne  end
inline fun >    int int   -> bool : gt  end
inline fun >=   int int   -> bool : ge  end
inline fun <    int int   -> bool : lt  end
inline fun <=   int int   -> bool : le  end
inline fun &&   bool bool -> bool : and end
inline fun ||   bool bool -> bool : or  end

inline fun & any any -> int : and cast(int) end
inline fun | any any -> int : or  cast(int) end
inline fun not bool -> bool : cast(int) true cast(int) != end

inline fun read int str int -> int : SYS_read syscall3 end
inline fun write int str int -> int : SYS_write syscall3 end
inline fun exit int :: SYS_exit syscall1 drop end

fun fputs fd:int buf:str :
    buf.len buf fd write drop
end

inline fun puts str : stdout fputs end
inline fun eputs str : stderr fputs end
inline fun puti int : int::to_str puts end
inline fun eputi int : int::to_str eputs end

inline fun ptr+ int ptr -> ptr : swap cast(int) + cast(ptr) end
inline fun str+ int str -> str : swap cast(int) + cast(str) end

const PROT_READ 1 end
const PROT_WRITE 2 end
const MAP_PRIVATE 2 end
const MAP_ANONYMOUS 32 end
fun mmap length:int -> ptr :
    0
    0
    MAP_ANONYMOUS MAP_PRIVATE |
    PROT_READ PROT_WRITE |
    length
    NULL
    SYS_mmap syscall6 cast(ptr)
end

fun memcpy dst:ptr src:ptr len:int :
    0 take index bind
    while index len < do
        src index ptr+ load_byte
        dst index ptr+ store_byte
        index 1 + index =
    done
end

const SYS_read 0 end
const SYS_write 1 end
const SYS_open 2 end
const SYS_close 3 end
const SYS_mmap 9 end
const SYS_exit 60 end

impl int
    fun to_str self:self -> str :
        if self 0 == then
            "0" return
        fi

        self.count_digits
        dup 2 + mmap cast(str)
        10
        0
        take index base string digits bind

        self 0 < take is_negative bind
        if is_negative then
            self.abs self =
        fi

        while index digits < do
            self base % 48 +
            string index str+ cast(ptr) store_byte

            self base / self =
            index 1 + index =
        done

        if is_negative then
            45 string index str+ cast(ptr) store_byte
        fi

        string.reverse
        string
    end

    fun count_digits self:self -> int :
        if self 0 == then
            1 return
        fi

        self.abs self =
        0 take count bind

        while self 0 != do
            self 10 / self =
            count 1 + count =
        done

        count
    end

    inline fun abs self -> int :
        dup neg int::max
    end

    fun max v1:int v2:int -> int :
        if v1 v2 > then
            v1
        else
            v2
        fi
    end
end

impl str
    fun len self:self -> int :
        0 while self over str+ cast(ptr) load_byte NULL != do
            1 +
        done
    end

    fun copy self:self -> str :
        self.len
        self cast(ptr)
        over 1 + mmap peek copy bind
        memcpy

        copy cast(str)
    end

    fun reverse self:self :
        self.len 1 -
        0
        take i j bind

        while i j < do
            i self.nth  take i_char bind
            j self.nth  self i str+ cast(ptr) store_byte
            i_char      self j str+ cast(ptr) store_byte

            i 1 + i =
            j 1 - j =
        done
    end

    fun nth self:self n:int -> char :
        self n str+ cast(ptr) load_byte cast(char)
    end
end
