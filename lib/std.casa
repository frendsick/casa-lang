const NULL 0 end

const stdin  0 end
const stdout 1 end
const stderr 2 end

inline fun + int int -> int : add end
inline fun - int int -> int : sub end
inline fun * int int -> int : mul end
inline fun / int int -> int : div end
inline fun % int int -> int : mod end

inline fun ==   int int   -> bool : eq  end
inline fun !=   int int   -> bool : ne  end
inline fun >    int int   -> bool : gt  end
inline fun >=   int int   -> bool : ge  end
inline fun <    int int   -> bool : lt  end
inline fun <=   int int   -> bool : le  end
inline fun &&   bool bool -> bool : and end
inline fun ||   bool bool -> bool : or  end

inline fun & any any -> int : and cast(int) end
inline fun | any any -> int : or  cast(int) end
inline fun not bool -> bool : cast(int) true cast(int) != end

inline fun read int str int -> int : SYS_read syscall3 end
inline fun write int str int -> int : SYS_write syscall3 end
inline fun exit int :: SYS_exit syscall1 drop end

fun fputs fd:int buf:str :
    buf.len buf fd write drop
end

inline fun puts str : stdout fputs end
inline fun eputs str : stderr fputs end

inline fun ptr+ int ptr -> ptr : swap cast(int) + cast(ptr) end
inline fun str+ int str -> str : swap cast(int) + cast(str) end

const PROT_READ 1 end
const PROT_WRITE 2 end
const MAP_PRIVATE 2 end
const MAP_ANONYMOUS 32 end
fun mmap length:int -> ptr :
    0
    0
    MAP_ANONYMOUS MAP_PRIVATE |
    PROT_READ PROT_WRITE |
    length
    NULL
    SYS_mmap syscall6 cast(ptr)
end

fun memcpy dst:ptr src:ptr len:int :
    0 take index bind
    while index len < do
        src index ptr+ load_byte
        dst index ptr+ store_byte
        index 1 + index =
    done
end

const SYS_read 0 end
const SYS_write 1 end
const SYS_open 2 end
const SYS_close 3 end
const SYS_mmap 9 end
const SYS_exit 60 end

impl int
    inline fun abs int -> int :
        dup neg int::max
    end

    fun max v1:int v2:int -> int :
        if v1 v2 > then
            v1
        else
            v2
        fi
    end
end

impl str
    fun len self -> int :
        0 while self over str+ cast(ptr) load_byte NULL != do
            1 +
        done
    end

    fun copy self -> str :
        self.len
        self cast(ptr)
        over 1 + mmap peek copy bind
        memcpy

        copy cast(str)
    end

    fun reverse self :
        self.len 1 -
        0
        take i j bind

        while i j < do
            i self.nth  take i_char bind
            j self.nth  self i str+ cast(ptr) store_byte
            i_char      self j str+ cast(ptr) store_byte

            i 1 + i =
            j 1 - j =
        done
    end

    fun nth self n:int -> char :
        self n str+ cast(ptr) load_byte cast(char)
    end
end
